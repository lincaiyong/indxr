type:
    | '(' x=type ')' {paren_type(x)}
    | '*' x=type {star_expr(x)}
    | '[' ']' x=type {slice_type(x)}
    | '[' x=expression ']' y=type {array_type(x, y)}
    | 'struct' '{' x=struct_field* '}' {struct_type(x)}
    | 'func' '(' p=','.parameter* ','? ')' r=result_decl? {func_type(p, r)}
    | 'interface' '{' x=interface_field* '}' {interface_type(x)}
    | 'map' '[' x=type ']' y=type {map_type(x, y)}
    | 'chan' '<-' t=type {send_only_chan_type(t)}
    | '<-' 'chan' t=type {recv_only_chan_type(t)}
    | 'chan' t=type {bidirectional_chan_type(t)}
    | x=type_identifier '[' s=','.type+ ','? ']' {generic_type(x, s)}
    | type_identifier
type_identifier: type_qualified_name | type_name
type_qualified_name: x=IDENT '.' y=IDENT {type_qualified_name(x, y)}
type_name: x=IDENT {type_name(x)}

struct_field:
    | x=IDENT y=type? z=STRING? semi_comma {struct_field(x, y, z)}
    | star='*'? x=(type_qualified_name | type_name) '[' s=','.type+ ','? ']' y=STRING? semi_comma {struct_embed_field(star, x, s, y)}
semi_comma: ',' | semi

interface_field:
    | x=type_name semi {interface_embed_field(x)}
    | x=IDENT '(' p=','.parameter* ','? ')' r=result_decl? semi {interface_method_field(x, p, r)}
    | x='|'.type_constraint+ semi {interface_type_constraint(x)}
