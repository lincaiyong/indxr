# 文件是包名，import，文件级声明
file: n=package_decl i=import_decl* t=(function_decl | method_decl | const_decl | var_decl | type_decl)* END_OF_FILE {file(n, i, t)}

# PACKAGE DECLARATION #################

package_decl: 'package' n=package_ident ';' {n}
package_ident: n=IDENT {package_ident(n)}

# IMPORT DECLARATION ##################

import_decl:
    | 'import' '(' specs=(t=import_spec end_semi {t})* ')' ';' {import_decl(specs)}
    | 'import' specs=import_spec ';' {import_decl([specs])}
import_spec: name=(import_dot | import_ident)? path=import_path {import_spec(name, path)}
import_dot: d='.' {import_dot(d)}
import_ident: n=IDENT {import_ident(n)}
import_path: s=STRING {import_path(s)}

# FUNCTION DECLARATION ################

function_decl: 'func' n=func_ident t=generic_parameter_decl? '(' p=','.parameter* ','? ')' r=result_decl? b=block? ';' {function_decl(n, t, p, r, b)}
func_ident: n=IDENT {func_ident(n)}
parameter:
    | n=parameter_ident '...' t=type {ellipsis_parameter(n, t)}
    | n=parameter_ident t=type? {parameter(n, t)}
parameter_ident: n=IDENT {parameter_ident(n)}
result_decl:
    | '(' s=','.result+ ','? ')' {s}
    | r=type_only_result {[r]}
result:
    | n=result_ident t=type? {result(n, t)}
    | type_only_result
type_only_result: t=type {result(_, t)}
result_ident: n=IDENT {result_ident(n)}

# METHOD DECLARATION ##################

method_decl: 'func' '(' rc=receiver ')' n=method_ident '(' p=','.parameter* ','? ')' rs=result_decl? b=block? ';' {method_decl(rc, n, p, rs, b)}
method_ident: n=IDENT {method_ident(n)}
receiver: n=receiver_ident? star='*'? t=receiver_type_ident ('[' g=','.receiver_generic_type_ident+ ','? ']')? {receiver(n, star, t, g)}
receiver_ident: n=IDENT {receiver_ident(n)}
receiver_type_ident: n=IDENT {receiver_type_ident(n)}
receiver_generic_type_ident: n=IDENT {receiver_generic_type_ident(n)}

# CONST DECLARATION ###################

const_decl:
    | 'const' '(' c=const_spec_semi* ')' ';' {const_decl(c)}
    | 'const' c=const_spec ';' {const_decl([c])}
const_spec_semi: c=const_spec end_semi {c}
const_spec: i=','.const_ident+ (t=type? '=' e=expression_list)? {const_spec(i, t, e)}
const_ident: n=IDENT {const_ident(n)}

# VAR DECLARATION #####################

var_decl:
    | 'var' '(' x=var_spec_semi* ')' ';' {var_decl(x)}
    | 'var' x=var_spec ';' {var_decl([x])}
var_spec_semi: x=var_spec end_semi {x}
var_spec: i=','.var_ident+  (t=type? '=' e=expression_list)? {var_spec(i, t, e)}
var_ident: n=IDENT {var_ident(n)}

# TYPE DECLARATION ####################

type_decl:
    | 'type' '(' x=type_spec_semi* ')' ';' {type_decl(x)}
    | 'type' x=type_spec ';' {type_decl([x])}
type_spec_semi: x=type_spec end_semi {x}
type_spec:
    | x=type_ident t=generic_parameter_decl? '=' y=type {type_eq_spec(x, t, y)}
    | x=type_ident t=generic_parameter_decl? y=type {type_spec(x, t, y)}
type_ident: n=IDENT {type_ident(n)}

# GENERIC PARAMETER ###################

generic_parameter_decl: '[' x=','.generic_parameter+ ','? ']' {x}
generic_parameter:
    | n=generic_parameter_ident t=generic_union_constraint? {generic_parameter(n, t)}
generic_parameter_ident: n=IDENT {generic_parameter_ident(n)}
generic_union_constraint:
    | x=type_constraint !'|' {x}
    | x='|'.type_constraint+ {generic_union_constraint(x)}
type_constraint:
    | '~' x=type {generic_underlying_type_constraint(x)}
    | x=type {generic_type_constraint(x)}


method_spec: x=IDENT y=signature {field([x],y,_)}

end_semi: ';' | &')'| &'}'